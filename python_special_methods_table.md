# Python 特殊方法（魔术方法）参考表

## 📚 **基础特殊方法** (对应《Python for Data Analysis, 3E》第3章)

┌────────────────────┬───────────────────────────────┬─────────────────────┬────────────────────────────────────────────┐
│ 特殊方法            │ 何时被调用 (隐式调用)             │ 示例                │ 作用                                       │
├────────────────────┼───────────────────────────────┼─────────────────────┼────────────────────────────────────────────┤
│ __init__(self, ...)    │ 创建对象时 obj = MyClass(...)  │ p = Person('Alice') │ 初始化新创建的对象                         │
│ __str__(self)          │ print(obj) 或 str(obj)        │ print(p)            │ 返回对象的"非正式"字符串表示，方便用户阅读    │
│ __repr__(self)         │ 直接在解释器中输入 obj 回车      │ >>> p               │ 返回对象的"官方"字符串表示，通常用于调试      │
│ __len__(self)          │ len(obj)                      │ len(my_list)        │ 返回对象的长度                           │
│ __getitem__(self, key) │ obj[key] (索引或切片)          │ my_list[0]          │ 获取容器中指定键或索引的元素                │
│ __setitem__(self, key, value) │ obj[key] = value       │ my_list[0] = 10     │ 设置容器中指定键或索引的元素                │
│ __delitem__(self, key) │ del obj[key]                  │ del my_list[0]      │ 删除容器中指定键或索引的元素                │
│ __contains__(self, item) │ item in obj                 │ 'a' in my_string    │ 检查元素是否在容器中                       │
└────────────────────┴───────────────────────────────┴─────────────────────┴────────────────────────────────────────────┘

## 📊 **数值运算特殊方法**

┌────────────────────┬───────────────────────────────┬─────────────────────┬────────────────────────────────────────────┐
│ 特殊方法            │ 何时被调用 (隐式调用)             │ 示例                │ 作用                                       │
├────────────────────┼───────────────────────────────┼─────────────────────┼────────────────────────────────────────────┤
│ __add__(self, other)   │ obj1 + obj2                   │ 1 + 2               │ 定义加法行为                             │
│ __sub__(self, other)   │ obj1 - obj2                   │ 5 - 3               │ 定义减法行为                             │
│ __mul__(self, other)   │ obj1 * obj2                   │ 3 * 4               │ 定义乘法行为                             │
│ __truediv__(self, other) │ obj1 / obj2                 │ 10 / 3              │ 定义真除法行为                           │
│ __floordiv__(self, other) │ obj1 // obj2               │ 10 // 3             │ 定义整除法行为                           │
│ __mod__(self, other)   │ obj1 % obj2                   │ 10 % 3              │ 定义取模行为                             │
│ __pow__(self, other)   │ obj1 ** obj2                  │ 2 ** 3              │ 定义幂运算行为                           │
│ __eq__(self, other)    │ obj1 == obj2                  │ a == b              │ 定义相等比较                             │
│ __lt__(self, other)    │ obj1 < obj2                   │ a < b               │ 定义小于比较                             │
│ __gt__(self, other)    │ obj1 > obj2                   │ a > b               │ 定义大于比较                             │
└────────────────────┴───────────────────────────────┴─────────────────────┴────────────────────────────────────────────┘

## 🔄 **迭代器特殊方法**

┌────────────────────┬───────────────────────────────┬─────────────────────┬────────────────────────────────────────────┐
│ 特殊方法            │ 何时被调用 (隐式调用)             │ 示例                │ 作用                                       │
├────────────────────┼───────────────────────────────┼─────────────────────┼────────────────────────────────────────────┤
│ __iter__(self)         │ iter(obj) 或 for item in obj  │ for x in my_list:   │ 返回一个迭代器                            │
│ __next__(self)         │ next(iterator)                │ next(my_iter)       │ 从迭代器中获取下一个元素                   │
└────────────────────┴───────────────────────────────┴─────────────────────┴────────────────────────────────────────────┘

## 🏗️ **对象生命周期特殊方法**

┌────────────────────┬───────────────────────────────┬─────────────────────┬────────────────────────────────────────────┐
│ 特殊方法            │ 何时被调用 (隐式调用)             │ 示例                │ 作用                                       │
├────────────────────┼───────────────────────────────┼─────────────────────┼────────────────────────────────────────────┤
│ __new__(cls, ...)      │ 创建对象实例之前               │ obj = MyClass()     │ 控制对象的创建过程（很少直接使用）           │
│ __del__(self)          │ 对象被垃圾回收时               │ del obj             │ 对象销毁时的清理工作                       │
└────────────────────┴───────────────────────────────┴─────────────────────┴────────────────────────────────────────────┘

## 📝 **实用示例代码**

```python
class MyList:
    """自定义列表类，演示特殊方法的使用"""
    
    def __init__(self, items=None):
        """初始化方法"""
        self.items = items or []
    
    def __str__(self):
        """用户友好的字符串表示"""
        return f"MyList({self.items})"
    
    def __repr__(self):
        """开发者友好的字符串表示"""
        return f"MyList(items={self.items!r})"
    
    def __len__(self):
        """返回长度"""
        return len(self.items)
    
    def __getitem__(self, index):
        """支持索引访问"""
        return self.items[index]
    
    def __setitem__(self, index, value):
        """支持索引赋值"""
        self.items[index] = value
    
    def __contains__(self, item):
        """支持 in 操作符"""
        return item in self.items
    
    def __add__(self, other):
        """支持 + 操作符"""
        if isinstance(other, MyList):
            return MyList(self.items + other.items)
        return MyList(self.items + [other])
    
    def __iter__(self):
        """支持迭代"""
        return iter(self.items)

# 使用示例
my_list = MyList([1, 2, 3])
print(my_list)           # MyList([1, 2, 3])
print(len(my_list))      # 3
print(my_list[0])        # 1
print(2 in my_list)      # True
my_list[0] = 10
print(my_list)           # MyList([10, 2, 3])

# 迭代示例
for item in my_list:
    print(item)          # 10, 2, 3
```

## 💡 **学习要点**

### 1. **命名规范**
- 特殊方法总是以双下划线开始和结束（`__method__`）
- 也被称为"魔术方法"或"dunder方法"（double underscore）

### 2. **隐式调用**
- 这些方法通常不直接调用，而是通过Python的内置函数或操作符触发
- 例如：`len(obj)` 实际调用 `obj.__len__()`

### 3. **数据分析中的应用**
- pandas DataFrame 和 Series 大量使用这些特殊方法
- NumPy 数组也实现了这些方法来支持向量化操作
- 理解这些方法有助于更好地使用数据分析库

### 4. **最佳实践**
- 只实现你确实需要的特殊方法
- `__str__` 用于用户友好的显示，`__repr__` 用于开发调试
- 确保相关方法的行为一致（如实现了 `__eq__` 就应该考虑 `__hash__`）

---

*这个表格对应《Python for Data Analysis, 3E》第3章中关于Python内置数据结构的内容，是理解Python对象模型的重要基础。*